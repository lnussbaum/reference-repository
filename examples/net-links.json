# File : reference-repository/examples/net-links.json
# This is how the json file on the network API would look like.
# All comments are include in front of each property

{
  "type": "network_equipment", # The same for all network equipments. This is used by the API generator ! To not confuse with "kind" property which is used to distinguish network equipments kinds.
  "model": "xx", # the model must start with the constructor (Cisco,HP Procurve,Foundry,...) followed by the version (3750,...). This is anyway how constructors usually describe they equipments.
  "kind": "xx", # This tells what kind of network_equipement it is (router,switch,virtual,...)
  "uid": "xx" # This equipment's uid
  "site": "xx" # This equipment's site uid
  "snmp_community": "public" # the Read-Only SNMP community. Its is "public" on all equipments since decision in PS-61.
  "vlans": {
    "1":{"addresses":[],"description":"default"}
    "100": {  # 100 is the vlan id
      "addresses": [ # vlan interface ip address, by order of priority. The first one being the primary ip address, the other one are secondary ip addr
        "172.16.68.254",  # The primary ip address
        "10.47.255.254",  # The secondary ip address
      ]
      "mac": "FF:FF:FF:FF:FE" , # The vlan interface mac address. most often, this value is the same on all vlans
      "description": "PRODUCTION" # A description for the vlan
    }
    "naming_pattern": "Vlan%VLANID%" # The vlan interface naming pattern. So the vlan 100 is on interface "vlan100"
  }
  "routes": {
    "172.16.47.0/20": { # 172.16.47.0/20 is the destination network address
      "status": "static", # Can be "connected" or "static". "static" means this route was define by a command line on the router. 
      "via": "192.168.4.14", # gateway of this network, if status == static. Of course this gateway must be join-able by one of the network equipment vlan interface.
    }
    "172.16.95.0/20": { # 172.16.95.0/20 is the destination network address
      "status": "connected", # Can be "connected" or "static". "connected" means the destination network correspond to one of our local interfaces (vlan interface). This type of route is usually added automatically by the network equipment's Operating System when an IP address is added to a local interface.
    }
  }
  "channels": {
    "200": [  # 200 is the port channel id
      {
        "linecard": "2", # the linecard number
        "port": "7", # the port number on the linecard
      },
      {
        "linecard": "3", # the linecard number
        "port": "7", # the port number on the linecard
      }
    ]
    "naming_pattern": "Po%CHANNELID%"; # The naming pattern of all Channel Ports. The port channel 200 is on interface "Po200".
    "190": [  # 190 is the port channel id
      {
        "linecard": "1", # the linecard number
        "port": "8", # the port number on the linecard
      },
      {
        "linecard": "2", # the linecard number
        "port": "8", # the port number on the linecard
      }
      {
        "linecard": "3", # the linecard number
        "port": "8", # the port number on the linecard
      }
    ]
  }
  "linecards": [
    {},
    {
      "rate": "1G", # The rate of all interfaces on this linecard. unless overriden within port description
      "naming_pattern" : "Gi%LINECARD%/%PORT%", # the naming pattern of all interfaces on this linecard. unless overriden within port description
      "kind": "node", # The kind of all neighbors on all interfaces on this linecard. unless overriden within port description
      "ports":[
        {
          "uid": "<cluster>-<node_id>", # The neighbor uid on this link. This should be used to identify links aggregations (not necessary channels, just link aggregation).
        },
        {
          "uid": "server_uid", # The neighbor uid on this link.
          "kind": "server", # Redefinition of the neighbor's kind, according to the one already defined on the linecard description.
        }
      ]
    },
    {
      "rate": "1G", 
      "naming_pattern" : "Gi%LINECARD%/%PORT%", 
      "kind": "node", 
      "ports":[
        {
          "uid": "netgdx-1", 
          "port": "eth0", # The neighbor's port name on this link. This is mainly useful when the neighbor has many ports and is not described in the network API. Typically, "node"s and "server"s.
        },
        {
          "uid": "netgdx-1", # Second link to the node "netgdx-1"
          "port": "eth1", # The neighbor's port name on this link.
        },
        {
          "uid": "netgdx-1", # Third link to the node "netgdx-1"
          "port": "eth2", # The neighbor's port name on this link.
        }
      ]
    },
    {
      "rate": "1G", 
      "naming_pattern" : "Gi%LINECARD%/%PORT%", 
      "kind": "switch", 
      "ports":[
        {
          "uid": "<cluster>-<node_id>", 
          "kind": "node", # Redefinition of the neighbor's kind
        },
        {
          "uid": "switch01",
        },
        {
          "uid": "switch01", # The second link to the switch "switch01". But nothis says it is a Port-Channel. For now it is just 2 links aggregated for "switch01". You will have to look into "channels" to find if there is a port channel on these ports. Notice that they is no need to specify the neighbor "port" on this link. In fact that that information is redundant since "switch01" should be described in the network API where they would be its links to this network equipment. So setting "port" here can even be confusing if it is coherent with the one in the "switch01" API description.
        }
      ]
    },
    {
      "rate": "10G", # Ha, interesting, the 10G links
      "naming_pattern" : "Te%LINECARD%/%PORT%", # The naming pattern of 10G interfaces on this linecard
      "kind": "virtual", 
      "ports":[
        {
          "uid": "renater-lille", 
          "site": "renater", # 'renater-lille' is a virtual network equipment on site 'renater'. This its description is in the grid5000's network API level.
        },
        {
          "uid": "gw1-h.net-admin.lille.inria.fr", # This can be the link to the local labo. Not necessarily described on our network API, but definitely a 'virtual' network equipment
        }
      ]
    }
  ]
}

